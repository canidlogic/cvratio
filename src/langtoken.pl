#!/usr/bin/env perl
use strict;

=head1 NAME

langtoken.pl - Compile a mapping of language name tokens to ISO-639-1
language codes.

=head1 SYNOPSIS

  langtoken.pl < languages.txt > tokens.txt

=head1 DESCRIPTION

The input is the language list that was generated by the C<langlist.pl>
script.  The output is a mapping of language tokens to ISO 639-1
language codes, with the language code listed first and the token second
since the token may have space characters.  Multiple records may have
the same language code in this list, but the language tokens must all be
unique.

Deriving the language tokens from the language name field in the input
data list uses the following process.

First, the language name field is first split into multiple choices
according to semicolon dividers.

Second, if there is a comma within any choices, the comma and everything
following it is dropped.

Third, if there is a parenthetical (left parenthesis, content, right
parenthesis with no nested parentheses), then the whole parenthetical is
dropped.

Fourth, lowercase U-umlaut is replaced by lowercase U.  A check is then
made that the token only has US-ASCII characters.

Fifth, the token is converted to uppercase, leading and trailing
whitespace is trimmed, internal whitespace is compacted to single
spaces, and a check is made that the token is not empty.

The records for language codes C<nb> and C<nn> are both ignored
completely, and the C<no> record is used for Norwegian instead.

The token C<NDEBELE> is ignored, as the more specific north and south
tokens are used instead to differentiate between two language codes.

=cut

# ==================
# Program entrypoint
# ==================

# Check no arguments
#
($#ARGV < 0) or die "Not expecting program arguments!\n";

# Set I/O modes
#
binmode(STDIN, ":encoding(utf8) :crlf") or
  die "Failed to set input I/O mode!\n";

# Start a hash that will map language tokens to their codes
#
my %tkd;

# Read input to fill the hash
#
my $lnum = 0;
for(
    my $ltext = readline(STDIN);
    defined $ltext;
    $ltext = readline(STDIN)) {
  
  # Update line number
  $lnum++;
  
  # Drop any line breaks
  chomp $ltext;
  
  # Whitespace trim
  $ltext =~ s/^\s+//;
  $ltext =~ s/\s+$//;
  
  # Skip if blank
  (length($ltext) > 0) or next;
  
  # Get fields
  ($ltext =~ /^([a-z]{2})\s+(\S.*)$/) or
    die sprintf("Input line %d: Invalid record!\n", $lnum);
  
  my $lang_code = $1;
  my $lang_name = $2;
  
  # Skip the exceptional Norwegian records, as we will use the "no"
  # record for Norwegian instead
  if (($lang_code eq 'nb') or ($lang_code eq 'nn')) {
    next;
  }
  
  # Token list starts empty
  my @tokens;
  
  # If there are any semicolons, split name by semicolons; else, just
  # have a single token
  if ($lang_name =~ /;/) {
    @tokens = split /;/, $lang_name;
  } else {
    push @tokens, ($lang_name);
  }
  
  # Normalize each token
  for my $tk (@tokens) {
    # If there is a comma, drop the comma and everything after it
    $tk =~ s/,.*$//;
    
    # If there are any parentheticals, drop them
    $tk =~ s/\([^\(\)]*\)//g;
    
    # Change lowercase U-umlaut to lowercase U
    $tk =~ s/\x{fc}/u/g;
    
    # Make sure result is ASCII
    ($tk =~ /^[\x{20}-\x{7e}]*$/) or
      die sprintf("Input line %d: Invalid characters in name!\n",
                  $lnum);
    
    # Convert to uppercase, clean up whitespace, and check that not
    # empty
    $tk =~ tr/a-z/A-Z/;
    $tk =~ s/^\s+//;
    $tk =~ s/\s+$//;
    $tk =~ s/\s+/ /g;
    
    (length($tk) > 0) or
      die sprintf("Input line %d: Empty token result!\n", $lnum);
  }
  
  # Add tokens to mapping
  for my $tk (@tokens) {
    # Skip the NDEBELE token
    if ($tk eq 'NDEBELE') {
      next;
    }
    
    # If token already in mapping, verify it maps to the same character
    # code and then skip it
    if (defined $tkd{$tk}) {
      ($tkd{$tk} eq $lang_code) or
        die sprintf("Ambiguous token: %s\n", $tk);
      next;
    }
    
    # Add token to mapping
    $tkd{$tk} = $lang_code;
  }
}

# Print results
#
for my $k (sort keys %tkd) {
  printf "%s %s\n", $tkd{$k}, $k;
}

=head1 AUTHOR

Noah Johnson, C<noah.johnson@loupmail.com>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2023 Multimedia Data Technology Inc.

MIT License:

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut
